##	作业2（课前）

*	姓名: xxx

*	学号: xxx

*	作业内容: 运行 `Test` 文件下的程序 `test.sln`，分析 `C语言` 中的各类数据在内存中的分布情况，回答问题(具体要求见下文)

<br><br>

##	作业要求

运行 `Test` 文件下的程序 `test.sln`，分析 `C语言` 中的各类数据在内存中的分布情况，回答以下问题：

1.	代码区，数据区（静态变量、全局变量和局部变量）分别对应的地址的相对大小；（哪些位于高地址，哪些位于低地址）

2.	通过 `malloc` 函数分配的内存空间 是否与 `局部变量` 的的内存空间在同一个范围？

3.	函数调用过程中，栈增长的方向是怎样的？形参和实参是如何关联的？

4.	【一般变量】，【指针类型变量】和【&】这三类变量之间的关联是怎样的？

注意：为了使得验证环境不受其他因素干扰，一定要修改链接选项（见附件中的图），使 VS 禁用 ASLR(Address space layout randomization)

<br><br>

##	分析与解答

####	1. 代码区，数据区（静态变量、全局变量和局部变量）分别对应的地址的相对大小；（哪些位于高地址，哪些位于低地址）

*	全局变量 ---> 高地址

	按照声明顺序，从低地址向高地址增长(不是栈的形式)，且进行了初始化的变量在前，未初始化的在后

	举例。对于以下代码，

	```c
	#include <stdio.h>

	int g1, g2=2, g3=3, g4=0;

	int main(){
		return 0;
		// g2, g3, g4 进行了显式初始化
		printf("0x%08x\n",g2);		// 全局变量g2的内存地址为：0x0041f180;
		printf("0x%08x\n",g3);		// 全局变量g3的内存地址为：0x0041f184;
		printf("0x%08x\n",g4);		// 全局变量g4的内存地址为：0x0041f188;

		// g1 未显式初始化
		printf("0x%08x\n",g1);		// 全局变量g1的内存地址为：0x0041f18c;
	}
	```

<br>

*	静态变量 ---> 高地址

	静态变量与全局变量类似，也是按照声明顺序，从低地址向高地址增长(不是栈的形式)，且进行了初始化的变量在前，未初始化的在后

	```c
	#include <stdio.h>

	int main(){
		static int s1=0,s2,s4,s3=0;

		// s1, s3 是显式初始化的静态变量，按其声明的顺序放在前面
		printf("0x%08x\n",s1);			// 静态变量s1的内存地址为：0x0042318c;
		printf("0x%08x\n",s3);			// 静态变量s3的内存地址为：0x00423190;

		// s2, s4 未显式初始化，按顺序放在后面
		printf("0x%08x\n",s2);			// 静态变量s2的内存地址为：0x00423194;
		printf("0x%08x\n",s4);			// 静态变量s4的内存地址为：0x00423198;
	}
	// 
	```

<br>

*	代码区 ---> 高地址

	```c
	#include <stdio.h>

	double add1(double a, double b);
	int add2(int a, int b);

	int main(){
		printf("0x%08x\n",add1);		// add1函数的入口地址为: 0x00401005
		printf("0x%08x\n",add2);		// add2函数的入口地址为: 0x0040100a
		printf("0x%08x\n", main);		// main函数的入口地址为: 0x0040100f
		return 0;
	}

	double add1(double a, double b){
		return a + b;
	}

	int add2(int a, int b){
		return a + b;
	}

	// TODO
	// 疑问：为什么每个地址之间相差 5 个字节？
	```

<br>

*	局部变量 ---> 低地址

	按照声明顺序，从高地址向低地址增长(栈的形式)，不同于全局变量和静态变量

	另外，是否进行初始化，不会改变其顺序

	```c
	#include <stdio.h>

	int main(){
		int a, b=2, c=3, d;
		printf("0x%08x\n", &a);		// 局部变量d的内存地址为：0x0018ff28;
		printf("0x%08x\n", &b);		// 局部变量c的内存地址为：0x0018ff2c;
		printf("0x%08x\n", &c);		// 局部变量b的内存地址为：0x0018ff30;
		printf("0x%08x\n", &d);		// 局部变量a的内存地址为：0x0018ff34;
		return 0;
	}
	```

*	关于局部变量的补充说明

	设有如下局部变量

	```cpp
	int main(){
		int v1 = 1, *p1 = &v1;	// 越后面的变量，地址越小
		int v2 = 2, *p2 = &v2;
	}
	```

	若 `p2` 的地址是 `0x0018ff28`，即 `&p2 == 0x0018ff28`，则

	```
	address			addr的含义		value, x86小端		val的含义
	0x0018ff28		&p2			2c ff 18 00		p2, &v2 (0x0018ff2c)
	0x0018ff2c		p2, &v2			02 00 00 00		*p2, v2 (2)
	0x0018ff30		&p1			34 ff 18 00		p1, &v1 (0x0018ff34)
	0x0018ff34		p1, &v1			01 00 00 00		*p1, v1 (1)
	```

	先开辟一段空间，再从高低值向低地址放东西。也就是，先迈一大步，再一步步往回走

	假设栈空间是 `0x0018ff00 ~ 0x0018ff38`

	则栈底 `bp` 是 `0x0018ff00`, 栈顶 `sp` 是 `0x0018ff38`

	声明局部变量时，后声明的变量放在高地址，先声明的放在低地址

	对于 `int v1=1, *p1=&v1, v2=2, *p2=&v2;`

	首先 `sp -= 4` 来到 `0x0018ff34`, 然后在 `34~37` 放入 `v1` 的值 `1`, 由于 x86 是小端，所以

	```
	0x0018ff34	01
	0x0018ff35	00
	0x0018ff36	00
	0x0018ff37	00
	```

	同理，存放指针 `p1` 的时候，首先是 `sp -= 4` (32位系统指针长度也是4字节), 来到 `0x0018ff30`, 然后在 `30~33` 放入 `p1` 的值, 即 `v1` 的地址 `0x0018ff34`, 由于 x86 是小端，所以

	```
	0x0018ff30	34
	0x0018ff31	ff
	0x0018ff32	18
	0x0018ff33	00
	```

<br><br>

####	2. 通过 `malloc` 函数分配的内存空间 是否与 `局部变量` 的的内存空间在同一个范围？

*	不在同一范围，示例如下

	```c
	#include <stdio.h>
	#include <stdlib.h>

	int main(){
		int a, *p = &a;
		printf("0x%08x\n", &p);			// 0x0018ff30
		printf("0x%08x\n", p);			// 0x0018ff34

		p = (int *)malloc(1);
		printf("0x%08x\n", &p);			// 0x0018ff30
		printf("0x%08x\n", p);			// 0x00555c10

		return 0;
	}

	// 当执行完 malloc 之后, &p 不变, 但是 p 所指向的变量地址
	// 从 0x0018ff34 变成了 0x00555c10
	```

<br><br>

####	3. 函数调用过程中，栈增长的方向是怎样的？形参和实参是如何关联的？

*	按照形参表逆序入栈，前面的形参在低地址，后面的形参在高地址。也就是说，和局部变量入栈的方式相同

	```c
	#include <stdio.h>

	int add(int a, int b){
		printf("0x%08x\t0x%08x\n", &b, b);		// 形参b地址 0x0018fedc
		printf("0x%08x\t0x%08x\n", &a, a);		// 形参a地址 0x0018fed8
		return (a+b);
	}

	int main(){
		int a = 1, b = 2;
		int sum = 0;
		printf("0x%08x\n", &b);			// 实参b地址 0x0018ff30
		printf("0x%08x\n", &a);			// 实参a地址 0x0018ff34
		
		sum = add(a, b);
		return 0;
	}
	```

*	实参的值直接复制给形参，形参相当于是实参的副本。

	实参和形参存放在不同的位置。如上面的注释所示，实参 `b` 地址是 `0x0018ff30`，而形参 `b` 地址是 `0x0018fedc`

<br><br>

####	4. 【一般变量】，【指针类型变量】和【&】这三类变量之间的关联是怎样的？

*	设有如下定义

	```c
	int main(){
		int a = 0;
		int *p = &a;
	}
	```

	则 `a == *p`, `&a == p`

	同时，由于 a 和 p 都是局部变量，两者的地址 `&a` 和 `&p` 有如下关系

	`&a - 4 == p - 4 == &p`

	关于具体的地址示例，已经在作业第一题的【关于局部变量的补充说明】中给出了详细描述，这里不再赘述

<br><br>

##	关于`Visual Studio Debug`的参考链接

*	[VS内存查看和分析](https://jingyan.baidu.com/article/08b6a591b387b914a809228a.html)

*	[VS不支持c99，必须在所有局部变量声明完成后才能写其他语句](https://blog.csdn.net/yongh701/article/details/53837520)
