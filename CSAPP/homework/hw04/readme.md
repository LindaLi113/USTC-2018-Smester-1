##	程序设计与计算机系统第六章作业

*	题目

	6.25, 6.29, 6.34, 6.38. 6.41

	注: 题目来自英文版CSAPP, 3rd Edition

*	6.25

	根据书第427页的 `高速缓存小结`, 我们可以得到如下公式

	```
	C = B x E x S
	s = log2(S)
	b = log2(B)
	t = m - (b + s)
	```

	所以对于第一行所给的条件
	
	```
	m = 32
	C = 1024
	B = 4
	E = 4
	```

	可以得到

	```
	S = C / (B x E) = 1024 / (4x4) = 64
	s = log2(S) = 6
	b = log2(B) = 2
	t = m - (b + s) = 32 - 8 = 24
	```

	同理可以得到其他几行的数据，因此可以得到如下表格

	| Cache | m  |  C   | B  | E   | S   | t  | s | b |
	|:------|:---|:-----|:---|:----|:----|:---|:--|:--|
	| 1     | 32 | 1024 | 4  | 4   | 64  | 24 | 6 | 2 |
	| 2     | 32 | 1024 | 4  | 256 | 1   | 30 | 0 | 2 |
	| 3     | 32 | 1024 | 8  | 1   | 128 | 22 | 7 | 3 |
	| 4     | 32 | 1024 | 8  | 128 | 1   | 29 | 0 | 3 |
	| 5     | 32 | 1024 | 32 | 1   | 32  | 22 | 5 | 5 |
	| 6     | 32 | 1024 | 32 | 4   | 8   | 24 | 3 | 5 |

	<br>

*	6.29

	由题可得

	```
	m = 12
	E = 2
	B = 4 ==> b = 2
	S = 4 ==> s = 2
	t = m - (b + s) = 12 - 4 = 8
	```

	*	A

		根据书本 `P428` 的图 `6-29`, 地址格式的最低 `b` 位是 `CO`, 接下来的低 `s` 位是 `CI`, 然后接下来的低 `t` 位是 `CT`

		不同于习题 `6.13`, 本题的 `m=12`, 地址格式一共有 `13` 位, 所以地址格式的最高位是空的, 所以可以得到如下地址格式字段分布

		| 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
		|:--:|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|
		| -  | CT | CT | CT | CT | CT | CT | CT | CT | CI | CI | CO | CO |

	*	B

		对于第一行的 `0x834` 读操作, 因为

		```
		0x834 = (1000 0011 0100)2
		```

		对照 `A` 中的字段分布, 可以得到

		```
		CI = (01)2 = 0x01 = 1
		CT = (1000 0011)2 = 0x83
		CO = (00)2 = 0x00 = 0
		```

		查找题表可知, 组索引 `CI=1` 且 标记 `CT=0x83` 的块的有效位为 `0`, 说明这是一个无效块, 访问时属于 `Miss`, 需要从内存中调入数据(调入的数据内容未知, 即 unknown)

		对于第二行的 `0x836 == (1000 0011 0110)2` 写操作, 可以得到

		```
		CI = (01)2 = 0x01 = 1
		CT = (1000 0011)2 = 0x83
		CO = (10)2 = 0x10 = 2
		```

		刚好读到第一行写入的内容的字节 `2`, 但是由于第一行调入的内容未知, 所以这里的内容也是未知, 即 unknown

		对于第三行的 `0xFFD = (1111 1111 1101)2` 读操作, 可以得到

		```
		CI = (11)2 = 0x11 = 3
		CT = (1111 1111)2 = 0xff
		CO = (01)2 = 0x01 = 1
		```

		组索引 `CO=1`, 标记 `CT=0xff`, 可以看到其有效位为 `1`, 说明是 `Hit` 命中缓存. 再查看块偏移 `CO=1` 的位置, 即字节 `1`, 其数据为 `C0`

		所以可以得到如下表格

		| Operation | Address | Hit? | Read value (or unknown) |
		|:----------|:--------|:-----|:------------------------|
		| Read      | 0x834   | Miss | unknown                 |
		| Write     | 0x836   | Hit  | unknown                 |
		| Read      | 0xFFD   | Hit  | 0xC0                    |

	<br>

*	6.34

	*	由题可得 B = 16, E = 1, C = 32, S = C/B/E = 2

		数组的每一行有 4 个 int 元素, 每一行的大小为 16 字节 == B

		对于 src 数组, 题目采用的是行优先访问, 对于 dst 数组, 题目采用的是列优先

		因此可以得到如下表格

	*	dst 数组

		|    | 列0 | 列1 | 列2 | 列3 |
		|----|---|----|---|---|
		| 行0 | m | m | m | m |
		| 行1 | m | m | m | m |
		| 行2 | m | m | m | m |
		| 行3 | m | m | m | m |

	*	src 数组

		|    | 列0 | 列1 | 列2 | 列3 |
		|----|---|---|---|---|
		| 行0 | m | m | h | m |
		| 行1 | m | h | m | h |
		| 行1 | m | m | h | m |
		| 行1 | m | h | m | h |

	<br>

*	6.38

	*	A

		外循环 16 次, 内循环 16 次, 每次写 4 次, 所以一共写 `16x16x4 = 1024` 次

	*	B

		因为 `sizeof(int) == 4`, 所以 `sizeof(point_color) == 16`

		又因为 `cache` 的块大小为 `B = 32B`

		由于 `cache` 初始为空, 所以第一步 `square[0][0].c = 0` 肯定是 `Miss`. 然后会在 `cache` 中存入 `32/16 = 2` 个 `point_color`

		这样, 在这次内循环中接下来的

		```
		square[0][0].m = 0
		square[0][0].y = 0
		square[0][0].k = 0
		```

		以及下次内循环中的

		```
		square[0][1].c = 0
		square[0][1].m = 0
		square[0][1].y = 0
		square[0][1].k = 0
		```

		数据都被加载到 `cache` 里面了, 所以使用的时候都是 `Hit`

		因此每 `8` 次写入过程会有 `1` 次 `Miss`

		总的写入次数是 `16x16x4=1024`, 即一共有 `1024/8=128` 次 `Miss`

	*	C

		由上题的分析可以得到 `MissRate = 1/8`

	<br>

*	6.41

	同 6.38, 因为 `sizeof(char) == 1`, 所以 `sizeof(pixel) == 4`, 

	又因为 `cache` 的块大小为 `B = 4B`

	由于 `cache` 初始为空, 所以第一步 `buffer[0][0].r = 0;` 肯定是 `Miss`

	然后会在 `cache` 中存入 `4/4 = 1` 个 `pixel`

	这样, 在这次内循环中接下来的

	```
	buffer[0][0].g = 0
	buffer[0][0].b = 0
	buffer[0][0].a = 0
	```

	都被加载到了 `cache`, 所以使用的时候都是 `Hit`

	下一次循环又重复这样的过程. 因此可以得到 `MissRate = 1/4`

	<br>
